module mojo_top (
        input clk,                  // 50MHz clock
        input rst_n,                // reset button (active low)
        output led [8],             // 8 user controllable LEDs
        input cclk,                 // configuration clock, AVR ready when high
        output spi_miso,            // AVR SPI MISO
        input spi_ss,               // AVR SPI Slave Select
        input spi_mosi,             // AVR SPI MOSI
        input spi_sck,              // AVR SPI Clock
        output spi_channel [4],     // AVR general purpose pins (used by default to select ADC channel)
        input avr_tx,               // AVR TX (FPGA RX)
        output avr_rx,              // AVR RX (FPGA TX)
        input avr_rx_busy,          // AVR RX buffer full
        output io_led [3][8],       // LEDs on IO Shield
        output io_seg [8],          // 7-segment LEDs on IO Shield
        output io_sel [4],          // Digit select on IO Shield
        input io_button [5],        // 5 buttons on IO Shield
        input io_dip [3][8]         // DIP switches on IO Shield 
        ) {
    
    sig rst;                        // reset signal
    
    alu8 alu8;
    alu8_test_format test8;
  
    .clk(clk) {
        // The reset conditioner is used to synchronize the reset signal to the FPGA
        // clock. This ensures the entire FPGA comes out of reset at the same time.
        reset_conditioner reset_cond;    
    }
    
    always {
  
        reset_cond.in = ~rst_n;     // input raw inverted reset signal
        rst = reset_cond.out;       // conditioned reset_cond
        
        test8.clk = clk;
        test8.rst = rst;
        test8.trigger = b0;
        test8.alu8_out=alu8.alu;
    
        alu8.alufn = 6b0;
        alu8.a = 8b0;
        alu8.b = 8b0;
            
    
        led = 8h00;                 // turn LEDs off
        spi_miso = bz;              // not using SPI
        spi_channel = bzzzz;        // not using flags
        avr_rx = bz;                // not using serial port
        
        io_led = 3x{{8h00}};        // turn LEDs off
        io_seg = 8hff;              // turn segments off
        io_sel = 4hf;               // select no digits
            
  
        
        case(io_dip[2][7]) {
          b1:
            test8.trigger = b1;
            alu8.alufn = test8.alufn;
            alu8.a = test8.alu8_in[1];
            alu8.b = test8.alu8_in[0]; 
            io_led[0] = alu8.alu;
            test8.alu8_out = alu8.alu;
            led[1:0] = test8.states; 
            led[7] = test8.result;

              
          b0:
            io_led[0] = alu8.alu; 
            alu8.alufn = io_dip[2][5:0];
            alu8.a = io_dip[0];
            alu8.b = io_dip[1];
            
             
        }
  }    
}
module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs    
    input cclk,             // configuration clock, AVR ready when 
    output spi_miso,        // AVR SPI MISO    high
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR S
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)    PI Clock
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)    
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield        
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],    // DIP switches on IO Shield
    input sum,
    input carry,
    output pina,
    output pinb,
    output pinc     
  ) 
  
  {

  
  .clk(clk) {
    .rst(rst_n) {
      fsm state = {STATE1, STATE2, STATE3, STATE4, STATE5, STATE6, STATE7, STATE8, ERROR, SUCCESS};
      dff counter[3];  
      }
  }
 
  
  
  always {
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    pina=b1;
    pinb=b1;
    pinc=b1;
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits

    case (state.q) {
      state.STATE1:
          counter.d=3b0;
          pina = counter.q[2];
          pinb = counter.q[1];
          pinc = counter.q[0];
        if (carry==0 && sum ==0) {
          state.d = state.STATE2;
          io_led[0][0] = 1; }
        else { state.d = state.ERROR; }
          
      state.STATE2:
        counter.d = counter.q + 1;
        pina = counter.q[2];
        pinb = counter.q[1];
        pinc = counter.q[0];
        if (carry ==0 && sum ==1){
          state.d = state.STATE3;
          io_led[0][1] = 1; }
        else { state.d = state.ERROR; }
       
      state.STATE3:
        counter.d = counter.q + 1;
        pina = counter.q[2];
        pinb = counter.q[1];
        pinc = counter.q[0];
        if (carry ==0 && sum ==1){
          state.d = state.STATE4;
          io_led[0][2] = 1;}
        else { state.d = state.ERROR; }
          
      state.STATE4:
        counter.d = counter.q + 1;
        pina = counter.q[2];
        pinb = counter.q[1];
        pinc = counter.q[0];
        if (carry ==1 && sum ==0){
          state.d = state.STATE5;
          io_led[0][3] = 1;}
        else { state.d = state.ERROR; }
          
      state.STATE5:
        counter.d = counter.q + 1;
        pina = counter.q[2];
        pinb = counter.q[1];
        pinc = counter.q[0];
        if (carry ==0 && sum ==1){
          state.d = state.STATE6;
          io_led[0][4] = 1;}
        else { state.d = state.ERROR; }
        
      state.STATE6:
        counter.d = counter.q + 1;
        pina = counter.q[2];
        pinb = counter.q[1];
        pinc = counter.q[0];
        if (carry ==1 && sum ==0){
          state.d = state.STATE7;
          io_led[0][5] = 1;}
        else { state.d = state.ERROR; }
        
      state.STATE7:
        counter.d = counter.q + 1;
        pina = counter.q[2];
        pinb = counter.q[1];
        pinc = counter.q[0];
        if (carry ==1 && sum ==0){
          state.d = state.STATE8;
          io_led[0][6] = 1;}
        else { state.d = state.ERROR; }
        
      state.STATE8:
        counter.d = counter.q + 1;
        pina = counter.q[2];
        pinb = counter.q[1];
        pinc = counter.q[0];
        if (carry ==1 && sum ==1){
          state.d = state.SUCCESS;
          io_led[0][7] = 1;}
        else { state.d = state.ERROR; }
        
      state.SUCCESS:
        io_led[2][0] = 1;
        
      state.ERROR:
        io_led[1][0] = 1;
        }
    }
  }

module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs    
    input cclk,             // configuration clock, AVR ready when 
    output spi_miso,        // AVR SPI MISO    high
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR S
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)    PI Clock
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)    
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield       
    input sum,
    input carry,
    output pina,
    output pinb,
    output pinc     
  ) 
  
  {

  .clk(clk) {
    .rst(rst_n) {
      fsm state = {STATE1, STATE2, STATE3, STATE4, STATE5, STATE6, STATE7, STATE8, ERROR, SUCCESS};
    }
    dff counter[28];
  }
 
  
  
  always {
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    pina = b0;
    pinb = b0;
    pinc = b0;
    io_led = 3x{{8h00}};    // turn LEDs off

    case (state.q) {
      state.STATE1:
          counter.d = 0;
          pina = counter.q[27];
          pinb = counter.q[26];
          pinc = counter.q[25];
        if (carry == 0 && sum == 0) {
          state.d = state.STATE2;
          io_led[0][0] = 1; 
        } else { 
          state.d = state.ERROR; 
        }
          
      state.STATE2:
          counter.d = counter.q + 1;
          pina = counter.q[27];
          pinb = counter.q[26];
          pinc = counter.q[25];
        if (carry == 0 && sum == 1) {
          state.d = state.STATE3;
          io_led[0][1] = 1; 
        } else { 
          state.d = state.ERROR; 
        }
       
      state.STATE3:
          counter.d = counter.q + 1;
          pina = counter.q[27];
          pinb = counter.q[26];
          pinc = counter.q[25];
        if (carry == 0 && sum == 1) {
          state.d = state.STATE4;
          io_led[0][2] = 1;
        } else { 
          state.d = state.ERROR; 
        }
          
      state.STATE4:
          counter.d = counter.q + 1;
          pina = counter.q[27];
          pinb = counter.q[26];
          pinc = counter.q[25];
        if (carry == 1 && sum == 0) {
          state.d = state.STATE5;
          io_led[0][3] = 1;
        } else { 
          state.d = state.ERROR; 
        }
          
      state.STATE5:
          counter.d = counter.q + 1;
          pina = counter.q[27];
          pinb = counter.q[26];
          pinc = counter.q[25];
        if (carry == 0 && sum == 1) {
          state.d = state.STATE6;
          io_led[0][4] = 1;
        } else { 
          state.d = state.ERROR; 
        }
        
      state.STATE6:
          counter.d = counter.q + 1;
          pina = counter.q[27];
          pinb = counter.q[26];
          pinc = counter.q[25];
        if (carry == 1 && sum == 0) {
          state.d = state.STATE7;
          io_led[0][5] = 1;
        } else { 
          state.d = state.ERROR; 
        }
        
      state.STATE7:
          counter.d = counter.q + 1;
          pina = counter.q[27];
          pinb = counter.q[26];
          pinc = counter.q[25];
        if (carry == 1 && sum == 0) {
          state.d = state.STATE8;
          io_led[0][6] = 1;
        } else { 
            state.d = state.ERROR; 
        }
        
      state.STATE8:
          counter.d = counter.q + 1;
          pina = counter.q[27];
          pinb = counter.q[26];
          pinc = counter.q[25];
        if (carry == 1 && sum == 1) {
          state.d = state.SUCCESS;
          io_led[0][7] = 1;
        } else { 
            state.d = state.ERROR; 
        }
        
      state.SUCCESS:
        io_led[1][0] = 1;
        
      state.ERROR:
        io_led[0][0] = 1;
     }
   }
 }
